# 环境配置

## 部署 InternLM

-  新建一个开发机

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114210953.png)

-  切换到 `Terminal` 输入 `bash` 命令，克隆一个已有的 `pytorch 2.0.1` 环境

```shell
bash
/root/share/install_conda_env_internlm_bash.sh InternLM
```

-  等待了十几分钟后，环境好了

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114211442.png)

-  激活/切换环境，安装依赖

```shell
conda activate InternLM

# 升级pip
python -m pip install --upgrade pip

pip install modelscope==1.9.5
pip install transformers==4.35.2
pip install streamlit==1.24.0
pip install sentencepiece==0.1.99
pip install accelerate==0.24.1
```

## 模型下载

-  使用本地已下载的，或是选择从 modelscope/huggingface 下载。

```shell
# local
mkdir -p /root/data/model/Shanghai_AI_Laboratory
cp -r /root/share/temp/model_repos/internlm-chat-7b /root/data/model/Shanghai_AI_Laboratory/internlm-chat-7b
```

## 配置 LangChain 相关环境

-  在完成 InternLM 的部署基础上，还需要安装以下依赖包：

```shell
pip install langchain==0.0.292
pip install gradio==4.4.0
pip install chromadb==0.4.15
pip install sentence-transformers==2.2.2
pip install unstructured==0.10.30
pip install markdown==3.3.7
```

-  还需要用到开源词向量模型 Sentence Transformer，也可以尝试其他的开源词向量模型
-  首先使用 `hugginface-cli` 命令行工具，安装依赖

```shell
pip install -U huggingface_hub
```

-  然后在和 `/root/data` 目录下新建python文件 `download_hf.py`，填入以下代码：
	- resume-download：断点续下
	- local-dir：本地存储路径。（linux环境下需要填写绝对路径）

```python
import os

# 下载模型
os.system('huggingface-cli download --resume-download sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2 --local-dir /root/data/model/sentence-transformer')
```

-  但可以使用 `huggingface 镜像`

```python
import os

# 设置环境变量
os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com'

# 下载模型
os.system('huggingface-cli download --resume-download sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2 --local-dir /root/data/model/sentence-transformer')
```

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114213743.png)

- 更多请见 [HF Mirror](https://hf-mirror.com/)

## NLTK 相关资源

- 在使用开源词向量模型构建开源词向量的时候，需要用到第三方库 `nltk` 的一些资源。正常情况下，其会自动从互联网上下载，但可能由于网络原因会导致下载中断，此处我们可以从国内仓库镜像地址下载相关资源，保存到服务器上。

```shell
cd /root
git clone https://gitee.com/yzy0612/nltk_data.git  --branch gh-pages
cd nltk_data
mv packages/*  ./
cd tokenizers
unzip punkt.zip
cd ../taggers
unzip averaged_perceptron_tagger.zip
```

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114213722.png)

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114214031.png)

## 下载本项目代码

-  将仓库克隆到本地

```shell
cd /root/data
git clone https://github.com/InternLM/tutorial
```

---

# 搭建知识库

## 数据收集

- 选择由上海人工智能实验室开源的一系列大模型工具开源仓库作为语料库来源，包括：

	- [OpenCompass](https://gitee.com/open-compass/opencompass)：面向大模型评测的一站式平台
	- [IMDeploy](https://gitee.com/InternLM/lmdeploy)：涵盖了 LLM 任务的全套轻量化、部署和服务解决方案的高效推理工具箱
	- [XTuner](https://gitee.com/InternLM/xtuner)：轻量级微调大语言模型的工具库
	- [InternLM-XComposer](https://gitee.com/InternLM/InternLM-XComposer)：浦语·灵笔，基于书生·浦语大语言模型研发的视觉-语言大模型
	- [Lagent](https://gitee.com/InternLM/lagent)：一个轻量级、开源的基于大语言模型的智能体（agent）框架
	- [InternLM](https://gitee.com/InternLM/InternLM)：一个开源的轻量级训练框架，旨在支持大模型训练而无需大量的依赖

-  首先需要将上述远程开源仓库 Clone 到本地，可以使用以下命令：

```shell
# 进入到数据库盘
cd /root/data
# clone 上述开源仓库
git clone https://gitee.com/open-compass/opencompass.git
git clone https://gitee.com/InternLM/lmdeploy.git
git clone https://gitee.com/InternLM/xtuner.git
git clone https://gitee.com/InternLM/InternLM-XComposer.git
git clone https://gitee.com/InternLM/lagent.git
git clone https://gitee.com/InternLM/InternLM.git
```

-  接着，为语料处理方便，我们将选用上述仓库中所有的 markdown、txt 文件作为示例语料库。注意，也可以选用其中的代码文件加入到知识库中，但需要针对代码文件格式进行额外处理（因为代码文件对逻辑联系要求较高，且规范性较强，在分割时最好基于代码模块进行分割再加入向量数据库）。

-  在 `/root/data` 下新建一个 `demo`目录，将该脚本和后续脚本均放在该目录下运行。

- 整体脚本如下：

```python
# 首先导入所需第三方库
from langchain.document_loaders import UnstructuredFileLoader
from langchain.document_loaders import UnstructuredMarkdownLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import Chroma
from langchain.embeddings.huggingface import HuggingFaceEmbeddings
from tqdm import tqdm
import os

# 1.首先将上述仓库中所有满足条件的文件路径找出来，我们定义一个函数，该函数将递归指定文件夹路径，返回其中所有满足条件（即后缀名为 .md 或者 .txt 的文件）的文件路径：

# 获取文件路径函数
def get_files(dir_path):
    # args：dir_path，目标文件夹路径
    file_list = []
    for filepath, dirnames, filenames in os.walk(dir_path):
        # os.walk 函数将递归遍历指定文件夹
        for filename in filenames:
            # 通过后缀名判断文件类型是否满足要求
            if filename.endswith(".md"):
                # 如果满足要求，将其绝对路径加入到结果列表
                file_list.append(os.path.join(filepath, filename))
            elif filename.endswith(".txt"):
                file_list.append(os.path.join(filepath, filename))
    return file_list

# 2.得到所有目标文件路径之后，我们可以使用 LangChain 提供的 FileLoader 对象来加载目标文件，得到由目标文件解析出的纯文本内容。由于不同类型的文件需要对应不同的 FileLoader，我们判断目标文件类型，并针对性调用对应类型的 FileLoader，同时，调用 FileLoader 对象的 load 方法来得到加载之后的纯文本对象：

# 加载文件函数
def get_text(dir_path):
    # args：dir_path，目标文件夹路径
    # 首先调用上文定义的函数得到目标文件路径列表
    file_lst = get_files(dir_path)
    # docs 存放加载之后的纯文本对象
    docs = []
    # 遍历所有目标文件
    for one_file in tqdm(file_lst):
        file_type = one_file.split('.')[-1]
        if file_type == 'md':
            loader = UnstructuredMarkdownLoader(one_file)
        elif file_type == 'txt':
            loader = UnstructuredFileLoader(one_file)
        else:
            # 如果是不符合条件的文件，直接跳过
            continue
        docs.extend(loader.load())
    # 使用上文函数，我们得到的 `docs` 为一个纯文本对象对应的列表。
    return docs 

# 目标文件夹
tar_dir = [
    "/root/data/InternLM",
    "/root/data/InternLM-XComposer",
    "/root/data/lagent",
    "/root/data/lmdeploy",
    "/root/data/opencompass",
    "/root/data/xtuner"
]

# 加载目标文件
docs = []
for dir_path in tar_dir:
    docs.extend(get_text(dir_path))

# 3. 得到该列表之后，我们就可以将它引入到 LangChain 框架中构建向量数据库。由纯文本对象构建向量数据库，我们需要先对文本进行分块，接着对文本块进行向量化。

# 对文本进行分块
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500, chunk_overlap=150)
split_docs = text_splitter.split_documents(docs)

# 4.选用开源词向量模型 [Sentence Transformer](https://huggingface.co/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2) 来进行文本向量化。LangChain 提供了直接引入 HuggingFace 开源社区中的模型进行向量化的接口：

# 加载开源词向量模型
embeddings = HuggingFaceEmbeddings(model_name="/root/data/model/sentence-transformer")

# 5.选择 Chroma 作为向量数据库，基于上文分块后的文档以及加载的开源向量化模型，将语料加载到指定路径下的向量数据库：

# 构建向量数据库
# 定义持久化路径
persist_directory = 'data_base/vector_db/chroma'
# 加载数据库
vectordb = Chroma.from_documents(
    documents=split_docs,
    embedding=embeddings,
    persist_directory=persist_directory  # 允许我们将persist_directory目录保存到磁盘上
)
# 将加载的向量数据库持久化到磁盘上
vectordb.persist()
```

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114215105.png)

> LangChain 提供了多种文本分块工具，此处使用字符串递归分割器，并选择分块大小为 500，块重叠长度为 150（由于篇幅限制，此处没有展示切割效果，可以自行尝试一下，想要深入学习 LangChain 文本分块可以参考教程 [《LangChain - Chat With Your Data》](https://github.com/datawhalechina/prompt-engineering-for-developers/blob/9dbcb48416eb8af9ff9447388838521dc0f9acb0/content/LangChain%20Chat%20with%20Your%20Data/1.%E7%AE%80%E4%BB%8B%20Introduction.md)


---

# InternLM 接入 LangChain

>  为便捷构建 LLM 应用，我们需要基于本地部署的 InternLM，继承 LangChain 的 LLM 类自定义一个 InternLM LLM 子类，从而实现将 InternLM 接入到 LangChain 框架中。完成 LangChain 的自定义 LLM 子类之后，可以以完全一致的方式调用 LangChain 的接口，而无需考虑底层模型调用的不一致。

-  在整体项目中，将代码封装为 `LLM.py`，后续将直接从该文件中引入自定义的 LLM 类。

```python
from langchain.llms.base import LLM
from typing import Any, List, Optional
from langchain.callbacks.manager import CallbackManagerForLLMRun
from transformers import AutoTokenizer, AutoModelForCausalLM
import torch

class InternLM_LLM(LLM):
    # 基于本地 InternLM 自定义 LLM 类
    tokenizer : AutoTokenizer = None
    model: AutoModelForCausalLM = None

    def __init__(self, model_path :str):
        # model_path: InternLM 模型路径
        # 从本地初始化模型
        super().__init__()
        print("正在从本地加载模型...")
        self.tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)
        self.model = AutoModelForCausalLM.from_pretrained(model_path, trust_remote_code=True).to(torch.bfloat16).cuda()
        self.model = self.model.eval()
        print("完成本地模型的加载")

    def _call(self, prompt : str, stop: Optional[List[str]] = None,
                run_manager: Optional[CallbackManagerForLLMRun] = None,
                **kwargs: Any):
        # 重写调用函数
        system_prompt = """You are an AI assistant whose name is InternLM (书生·浦语).
        - InternLM (书生·浦语) is a conversational language model that is developed by Shanghai AI Laboratory (上海人工智能实验室). It is designed to be helpful, honest, and harmless.
        - InternLM (书生·浦语) can understand and communicate fluently in the language chosen by the user such as English and 中文.
        """
        
        messages = [(system_prompt, '')]
        response, history = self.model.chat(self.tokenizer, prompt , history=messages)
        return response
        
    @property
    def _llm_type(self) -> str:
        return "InternLM"
```

-  在上述类定义中，我们分别重写了构造函数和 `_call` 函数：对于构造函数，我们在对象实例化的一开始加载本地部署的 InternLM 模型，从而避免每一次调用都需要重新加载模型带来的时间过长；`_call` 函数是 LLM 类的核心函数，LangChain 会调用该函数来调用 LLM，在该函数中，我们调用已实例化模型的 chat 方法，从而实现对模型的调用并返回调用结果。

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114215623.png)

# 构建检索问答链

-  LangChain 通过提供检索问答链对象来实现对于 RAG 全流程的封装。所谓检索问答链，即通过一个对象完成检索增强问答（即RAG）的全流程，针对 RAG 的更多概念，我们会在视频内容中讲解，也欢迎读者查阅该教程来进一步了解：[《LLM Universe》](https://github.com/datawhalechina/llm-universe/tree/main)。我们可以调用一个 LangChain 提供的 `RetrievalQA` 对象，通过初始化时填入已构建的数据库和自定义 LLM 作为参数，来简便地完成检索增强问答的全流程，LangChain 会自动完成基于用户提问进行检索、获取相关文档、拼接为合适的 Prompt 并交给 LLM 问答的全部流程。

- 新建 llmdemo.py 

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240219093135.png)

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240219093036.png)

---

# 部署 Web Demo


![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240114220009.png)

-  映射到本地端口

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240219095001.png)

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020240219095109.png)
