# 1 数据结构与算法简介、LeetCode 入门及攻略

## 1.1 数据结构与算法

### 1.1.1 概述

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020230912083424.png)

>  数据结构是程序的骨架，而算法则是程序的灵魂。
>  -- Pascal 语言之父 Niklaus Emil Wirth 《算法 + 数据结构 = 程序》

#### 1.1.1.1 什么是算法和数据结构

-  __算法 就是解决问题的方法或者过程__。如果把问题看成是函数，那么算法就是将输入转换为输出的过程。
-  __数据结构 是数据的计算机表示和相应的一组操作__。
-  __程序 则是算法和数据结构的具体实现__。
-  简单打比方： _程序设计_ 是 _做菜_，_数据结构_ 就是 _食材和调料_，_算法_ 则是 _不同的烹饪方式_ 或者是 _菜谱_。

#### 1.1.1.2 为什么要算法和数据结构

-  追求: _对于待解决的问题，选择更加合适的数据结构，使用花费时间更少、占用空间更小的算法_。
-  学习算法和数据结构，_是为了学会在编程中从时间复杂度、空间复杂度方面考虑解决方案_，训练自己的逻辑思维，从而写出高质量的代码，以此提升自己的编程技能，获取更高的工作汇报。
-  当然，就像是做菜，即使掌握了食材和调料，学会了烹饪方式，并不意味着就会做出一盘很好吃的炒菜。同理，掌握了算法和数据结构并不意味着就会写程序。

---

### 1.1.2 数据结构

>  Data Structure: 带有结构特性的数据元素的集合。

-  简单说，__数据结构__ 是指 __数据的组织结构，用来组织、存储数据__。
-  展开讲，数据结构研究的是 _数据的逻辑结构、物理结构以及它们之间的相互关系，并对这种结构定义相应的运算，设计出相应的算法，并确保经过这些运算以后所得到的的新结构仍保持原来的结构类型_。
-  __数据结构的作用__，就是 _为了提高计算机硬件的利用率_。而学习数据结构，就是为了帮助我们了解和掌握计算机中的数据是以何种方式进行组织、存储的。
-   __数据结构分类__: _逻辑结构_ 和 _物理结构_。

#### 1.1.2.1 数据的逻辑结构

>  Logical Structure: 数据元素之间的相互关系。

-  根据元素之间具有的不同关系，通常我们可以将数据的逻辑结构分为以下四种:

##### a.集合结构

>  集合结构: 数据元素同属于一个集合，除此之外无其他关系。

-  集合结构中的数据元素是无序的，并且每个数据元素都是唯一的，集合中没有相同的数据元素。集合结构很像数学意义上的 _集合_。

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020230912091053.png)

##### b.线性结构

>  线性结构: 数据元素之间是 __一对一__ 关系。

-  线性结构中的数据元素(除了第一个和最后一个元素)，左侧和右侧分别只有一个数据与其相邻。
-  线性结构类型包括: _数组、链表_，以及由它们衍生出来的 _栈、队列、哈希表_。

##### c.树形结构

>  树形结构: 数据元素之间是 __一对多__ 的层次关系。

-  最简单的属性结构是 _二叉树_。这种结构可以简单的表示为：_根、左子树、右子树_。左子树和右子树又有自己的字数。
-  树形结构类型还包括: _多叉树、字典树_ 等。

##### d.图形结构

>  图形结构: 数据元素之间是 __多对多__ 的关系。

-  图形结构是一种比属性结构更复杂的非线性结构，用于表示物件与物件之间的关系。
-  一张图由 _顶点_ 或 _结点_ 和连结它们的 _边_ 组成。
-  在图形结构中，任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。
-  图形结构类型包括: _无向图、有向图、连通图_ 等。

#### 1.1.2.2 数据的物理结构

>  Physical Structure: 数据的逻辑结构在计算机中的存储方式。

-  计算机内有多种存储结构，采用最多的是两种结构: __顺序存储结构__、__链式存储结构__。

##### a. 顺序存储结构

>  Sequential Storage Structure：将数据元素存放在一片地址连续的存储单元里，数据元素之间的逻辑关系通过数据元素的存储地址来直接反应。

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020230912102248.png)

- 在顺序存储结构中，__逻辑上相邻的数据元素在物理地址上也必然相邻__。

-  这种结构 
	- _优点: 简单、易理解，且实际占用最少的存储空间_。
	-  _缺点: 需要占用一片地址连续的存储单元；并且存储分配要事先进行；另外对于一些操作的时间效率较低(如移动、删除元素等操作)_。

##### b. 链式存储结构

> Linked Storage Structure: 将数据元素存放在任意的存储单元里，存储单元可以连续，也可以不连续。

![image text](https://raw.githubusercontent.com/burningmysoul2077/Notes/main/ScreenShots/Datawhale%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0/Pasted%20image%2020230912105111.png)

-  链式存储结构中，_逻辑上相邻的数据元素在物理地址上可能相邻，也可能不相邻_。__其在物理地址上的表现是随机的__。
-  链式存储结构中，一般 _将每个数据元素占用的若干单元的组合称为一个链结点_。每个链结点 _不仅要存放一个数据元素的数据信息，还要存放一个指出这个数据元素在逻辑关系的直接后继元素所在链结点的地址_，该地址被称为 __指针__。
	-  可以说，__数据元素之间的逻辑关系是通过指针来间接反映的__。

-  这种结构 
	-  _优点: 存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费；一些操作的时间效率远比顺序存储结构高(插入、移动、删除元素)_。
	-  _缺点: 不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链式存储结构比顺序存储结构的空间开销大。_

---

### 1.1.3 算法

>  Algorithm：解决特定问题求解步骤的准确而完整的描述，在计算机中表现为一系列指令的集合，算法代表着用系统的方法描述解决问题的策略机制。

-  简单说，_算法 是解决问题的方法_。
-  展开说，_算法 是某一系列运算步骤，它表达解决某一类计算问题的一般方法，对这类方法的任何一个输入，它可以按步骤一步一步计算，最终产生一个输出_。
-  它不依赖于任何一种语言，可以用 _自然语言、编程语言、伪代码、流程图_ 等来表示。

#### 1.1.3.1 算法的基本特性

-  __算法其实就是一系列的运算步骤__。除此之外，算法还应具备:
1.  _输入_ : 对于待解决的问题，都要以某种方式交给对应的算法。_在算法开始之前最初赋给算法的参数称为输入_。
2.  _输出_：算法是为了解决问题存在的，最终总需要返回一个结果。所以 _至少需要一个或多个参数作为算法的输出_。
3.  _有穷性:_ 算法必须在有限的步骤内结束，并且应该在一个可接受的时间内完成。
4.  _确定性：_ 组成算法的每一条指令必须有着清晰明确的含义，不能令读者在理解时产生二义性或者多义性。
5.  _可行性：_ 算法的每一步操作必须具有可执行性，在当前环境条件下可以通过有限次运算实现。也就是说，每一步都能通过执行有限次数完成，并且可以转换为程序在计算机上运行并得到正确的结果。

#### 1.1.3.2 算法追求的目标

-  研究算法的作用，就是为了使解决问题的方法变得更加高效。对于给定的问题，我们往往会有多种算法来解决。而不同算法的 **成本** 也是不同的。总体而言，一个优秀的算法至少应该追求以下两个目标：
1.  **所需运行时间更少（时间复杂度更低）**；
2.  **占用内存空间更小（空间复杂度更低）**。

-  假设计算机执行一条命令的时间为 1 纳秒（纯假设）
	-  第一种算法需要执行 100 纳秒
	-  第二种算法则需要执行 3 纳秒
-   _如果不考虑占用内存空间的话，很明显第二种算法比第一种算法要好很多_。

-  假设计算机一个内存单元的大小为一个字节
	-  第一种算法需要占用 3 个字节大小的内存空间，
	-  第二种算法则需要占用 100 个字节大小的内存空间
-  如果不考虑运行时间的话，很明显第一种算法比第二种算法要好很多。

-  现实中，往往是 __需要同时从运行时间、占用空间两个方面考虑问题__。当然，运行时间越少，占用空间越小的算法肯定是越好的，_但总是会有各种各样的因素导致了运行时间和占用空间不可兼顾_。比如，在程序运行时间过高时，我们可以考虑在空间上做文章，牺牲一定量的空间，来换取更短的运行时间。或者在程序对运行时间要求不是很高，而设备内存又有限的情况下，选择占用空间更小，但需要牺牲一定量的时间的算法。

- 除了对运行时间和占用内存空间的追求外，一个好的算法还应该追求以下目标：
1.  **正确性**：正确性是指算法能够满足具体问题的需求，程序运行正常，无语法错误，能够通过典型的软件测试，达到预期的需求。
2.  **可读性**：可读性指的是算法遵循标识符命名规则，简洁易懂，注释语句恰当，方便自己和他人阅读，便于后期修改和调试。
3.  **健壮性**：健壮性指的是算法对非法数据以及操作有较好的反应和处理。

-  这 3 个目标是算法的基本标准，是所有算法所必须满足的。一般我们对好的算法的评判标准就是上边提到的 **所需运行时间更少（时间复杂度更低）**、**占用内存空间更小（空间复杂度更低）**。

---

## 1.2 算法复杂度

### 1.2.1 简介

>  Algorithm Complexity：在问题的输入规模为 $n$ 的条件下，程序的时间使用情况和空间使用情况。

-  _算法分析 的目的在于改进算法_。正如上节所讲，_进行算法分析，就是从运行时间情况、空间使用情况两方面对算法进行分析_。

-  __比较两个算法的优劣通常有两种方法：__

| 事后统计 | 将两个算法各编写一个可执行程序，交给计算机执行，记录下各自的运行时间和占用存储空间的实际大小，从中挑选出最好的算法。 |     
| -------- | -------------------------------------------------------------------------------------------------------------------- | --- |
| 预先估算 | 在算法设计出来之后，根据算法中包含的步骤，估算出算法的运行时间和占用空间。比较两个算法估算值，从中挑选出最好的算法。 |                                                                                                                      |     |

-  大多数情况下，_我们会选择第 2 种方式_，因为第 1种方式的工作量实在太大。此外，即便是同一个算法，用不同语言实现，在不同的计算机上执行，所需要的运行时间都不尽相同。

-  _采用预先估算的方式下_，编译语言、计算机运行速度都不是我们所考虑的对象。我们只关心随着问题规模 $n$ 扩大时，_时间开销、空间开销的增长情况_。

-  _问题规模 $n$_ 指的是: _算法问题输入的数据量大小_。对于不同的算法，定义也不相同。
	-  排序算法中： $n$ 表示需要排序的元素数量。
	-  查找算法中：$n$ 表示查找范围内的元素综述：比如数组大小、二维矩阵大小、字符串长度、二叉树节点数、图的节点数、图的边界点等。
	-  二进制计算相关算法中：$n$ 表示二进制的展开宽度。

-  一般来说，_问题的输入规模越接近，相应的计算成本也越接近_。而随着问题输入规模的扩大，计算成本也呈上升趋势。

### 1.2.2 时间复杂度

#### 1.2.2.1 时间复杂度简介

>  Time Complexity：在问题的输入规模为 $n$ 的条件下，算法运行所需要花费的时间，记作 $T(n)$。

-  我们将 __基本操作次数__ 作为时间复杂度的度量标准。换句话说，_时间复杂度跟算法中基本操作次数的数量正相关_。
-  __基本操作__： 算法执行中的每一条语句。每一次基本操作都可在常数时间内完成。
-  基本操作是一个运行时间不依赖于操作数的操作。
	-  比如：两个整数相加的操作，如果两个数的规模不大，运行时间不依赖于整数的位数，则相加操作就可以看做是基本操作。
	-  反之，如果两个数的规模很大，相加操作依赖于两个数的位数，则两个数的相加操作不是一个基本操作，而每一位数的相加操作才是一个基本操作。

##### 具体例子

```python
def algorithm(n):
	fact = 1;
	for i in range(1, n+1):
		fact *= 1
	return fact
```

-  把上述算法中所有语句的执行次数加起来 1+ $n$ + $n$ + 1 = 2 $n$ + 2，可以用一个函数 $f(n)$ 来表达语句的执行次数：$f(n) = 2n + 2$。

-  则时间复杂度的函数可以表示为：$T(n) = O(f(n))$。它表示的是随着问题规模 $n$ 的增大，算法执行时间的增长趋势跟 $f(n)$ 相同。$O$ 是一种渐进符号，$T(n)$ 称作算法的 **渐进时间复杂度（Asymptotic Time Complexity）**，简称为 **时间复杂度**。

-  所谓「算法执行时间的增长趋势」是一个模糊的概念，通常我们要借助像上边公式中 $O$ 这样的「渐进符号」来表示时间复杂度。

#### 1.2.2.2 渐进符号

>  Asymptotic Symbol：专门用来刻画函数的增长速度的。简单来说，渐进符号只保留了 __最高阶幂__，忽略了一个函数中增长较慢的部分，比如 _低阶幂、系数、常量_。 因为当问题规模变的很大时，这几部分并不能左右增长趋势，所以可以忽略。

-  常用渐进符号三种:
	-  $\Theta$  渐进紧确界符号
	-  $O$  渐进上界符号
	-  $\Omega$  渐进下界符号



---

## 1.3 LeetCode 入门及攻略

---

## 1.4 练习题目

---

## 1.5 练习题目

---

# 总结
