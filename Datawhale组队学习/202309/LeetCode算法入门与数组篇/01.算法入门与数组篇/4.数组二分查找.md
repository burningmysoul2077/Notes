# 1 二分查找算法

## 1.1 算法简介

>  Binary Search Algorithm：也叫做折半查找算法、对数查找算法，是一种用于在有序数组中查找特定元素的高效搜索算法。

-  基本思想： _通过确定目标元素所在的区间范围，反复将查找范围减半，知道找到元素或找不到该元素为止_。

## 1.2 算法步骤

1.  __初始化__：首先，确定要查找的有序数据集合。可以是数组、列表，确保 _其中的元素按照升序或降序排列_。
2.  __确定查找范围__：将整个有序数组集合的查找范围确定为整个数组范围区间，即 _左边界 left 和 右边界 right_。
3.  __计算中间元素__：根据 $mid = [(left + right) / 2]$ 计算出中间元素下标位置 `mid`。
4.  __比较中间元素__：将目标元素 `target` 与中间元素 `nums[mid]` 进行比较：
	a. 如果 $target == nums[mid]$ ，说明找到 `target`，返回中间元素的下标位置 `mid`；
	b. 如果 $target < nums[mid]$，说明目标元素在左半部分 `([left, mid - 1])`，更新右边界为中间元素的前一个位置，即 `right = mid - 1`;
	c. 如果 $target > nums[mid]$，说明目标元素在右半部分 `([mid + 1, right])`，更新左边界为中间元素的后一个位置，即 `left = mid + 1`。
5. 重复步骤 3 ~ 4，直到找到目标元素时，返回中间元素下标位置；或者查找范围缩小为空 (左边界 > 右边界)，表示目标元素不存在，此时返回 `-1`。

## 1.3 算法思想

-  二分查找算法是经典的 __减而治之__ 的思想。
	-  _减_： 减少问题规模；
	-  _治_： 解决问题；
-  _减_ 和 _治_ 合起来就是 _排除法解决问题_，即：__每一次查找，排除掉一定不存在目标元素的区间，在剩下可能存在目标元素的区间中继续查找__。

## 1.4 简单二分查找例子

### [二分查找](https://leetcode.cn/problems/binary-search/)

---

# 2 二分查找知识

## 2.1 二分查找细节

-  真正在解决二分查找题目的时候还需要考虑更多细节。比如说以下几个问题：

1. **区间的开闭问题**：区间应该是左闭右闭区间 $[left, right]$，还是左闭右开区间 $[left, right)$？
2. **$mid$ 的取值问题**：$mid = \lfloor \frac{left + right}{2} \rfloor$，还是 $mid = \lfloor \frac{left + right + 1}{2} \rfloor$？
3. **出界条件的判断**：$left \le right$，还是 $left < right$？
4. **搜索区间范围的选择**：$left = mid + 1$、$right = mid - 1$、 $left = mid$、$right = mid$ 应该怎么写？

## 2.2 区间的开闭问题

### 左闭右闭区间

- 初始化时，`left = 0, right = len(nums) - 1`；
-  `left` 为数组第一个元素位置，`right` 为数组最后一个元素位置。
-  区间 `[left, right]` 左右边界上的点都能取到。

### 左闭右开区间

-  初始化时，`left = 0, right = len(nums)`；
-  `left` 为数组第一个元素位置，`right` 为数组最后一个元素的下一个位置。
-  区间 `[left, right)` 左边界的点都能取到，但右边界上的点不能取到。

### 结论

-  相对来说，左闭右开区间这种写法在解决问题的过程中，会使得问题变得复杂，需要考虑的情况更多，所以不建议。
-  建议：__全部使用 `左闭右闭区间` 这种写法__。

## 2.3  `mid` 取值问题

-  实际问题中，最常见的 `mid` 取值公式有两个：
1.  $mid = [(left + right) // 2]$
2.  $mid = [(left + right + 1) // 2]$
-  式子中 `//` 代表 _中间数向下取整_。

### 当待查找区间中的元素个数为 _奇数_

-  这两种取值公式 _都能取到中间元素的下标位置_。

![[Pasted image 20230920085210.png]]

###  当带查找区间中的元素个数为 _偶数_

-  第一个公式 _取到中间靠左边元素的下标位置_；
-  第二个公式 _取到中间靠右边元素的下标位置_。

![[Pasted image 20230920085237.png]]

-  这两个公式都起作用，这是因为二分查找算法的思路：根据每次选择中间位置上的数值来决定下一次在哪个区间查找元素。每一次选择的元素位置可以是中间位置，但并不是一定非得是区间中间位置元素，无论靠左、靠右、几分之一都可以。
-  但，_取区间中间位置在平均意义下所达到的效果最好，同时写起来最简单_。_多数情况下选择第一个公式_ ，不过 有些情况[[4.数组二分查找#3.2 排除法]] _要考虑第二个公式_ 。

### 另外两种变形

-  除了上面提到的这两种写法，我们还经常能看到下面两个公式：
1.  $mid = left + (right - left) // 2$
2.  $mid = left + (right - left + 1) // 2$

-  这两个公式分别等同于上两个公式，这种写法 _能够防止整型溢出问题_ (Python 中整型不会溢出)。

-  在 `left + right` 的数据量不会超过整型变量最大值时，这两种写法都没有问题。
-  在 `left + right` 的数据量可能会超过整型变量最大值时，最好使用第二种写法。
-  所以，为了统一和简化二分查找算法的写法，__建议统一写成第二种变型写法__。

## 2.4 出界条件的判断

-  `while` 语句出界判断条件通常有两种：
1.  `left <= right`
2.  `left < right`

### 先判断导致 `while` 语句出界的条件

1. 如果判断语句为 `left <= right`，并且查找的元素不在有序数组中，则 `while` 语句的出界条件是 `left > right`，也就是 `left == right + 1`，写成区间形式就是 `[right + 1,right]`，此时待查找区间为空，待查找区间中没有元素存在，此时终止循环时，可以直接返回 −1。
    - 比如说区间 `[3,2]`， 此时左边界大于右边界，直接终止循环，返回 −1 即可。
    
2. 如果判断语句为`left < right`，并且查找的元素不在有序数组中，则 `while` 语句出界条件是 `left == right`，写成区间形式就是 `[right,right]`。此时区间不为空，待查找区间还有一个元素存在，我们并不能确定查找的元素不在这个区间中，此时终止循环时，如果直接返回 −1 就是错误的。
    - 比如说区间 `[2,2]`，如果元素 `nums[2]` 刚好就是目标元素 `target`，此时终止循环，返回 −1 就漏掉了这个元素。

### 如何正确使用 `left < right` 

-  可以在出界之后增加一层判断，判断 `left` 所指向位置是否等于目标元素，如果是的话就返回 `left`，如果不是的话返回 −1。即：

```
# ...
    while left < right:
        # ...
    return left if nums[left] == target else -1
```

-  此外，`while` 判断语句用 `left < right` 有一个好处，就是在跳出循环的时候，一定是 `left == right`，我们就不用判断此时应该返回 `left` 还是 `right` 了。

## 2.5 搜索区间范围的选择

-  在进行区间范围选择的时候，通常有三种写法：

1.  `left = mid + 1`，`right = mid - 1`。 [[4.数组二分查找#3.1 直接法]]
2.  `left = mid + 1` ，`right = mid`。 [[4.数组二分查找#3.2 排除法]]
3.  `left = mid`，`right = mid - 1`。 [[4.数组二分查找#3.2 排除法]]

-  _选择区间范围是二分查找的一个难点_，写错了很容易造成死循环，或者得不到正确结果。

这其实跟二分查找算法的两种不同思路和三种写法有关。

- __思路 1：「直接法」—— 在循环体中找到元素后直接返回结果__。
- __思路 2：「排除法」—— 在循环体中排除目标元素一定不存在区间__。

---

