# 概念介绍

## 稳定算法与不稳定算法

## 原地排序

>  原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。
>  原地排序算法,_就是特指空间复杂度是 O(1) 的排序算法_。

# 1 冒泡排序

## 1.1 基本思想

>   Bubble Sort：经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。
>   这个过程就像水底的气泡一样从底部向上「冒泡」到水面，这也是冒泡排序法名字的由来。



## 1.2 算法步骤

-  假设数组的元素个数为 $n$ 个，则冒泡排序的算法步骤：

1.  将序列中第 1 个 元素与第 2 个元素进行比较，如果前者大于后者，则两者交换位置，否则不变；
2.  然后将第 2 个元素与第 3 个元素比较，如果前者大于后者，则两者交换位置，否则不变；
3.  依次类推，直到第 $n - 1$ 个元素与第 $n$ 个元素比较(或交换) 为止；
4.  经过第 1 趟排序，使得 $n$ 个元素中第 $i$ (现在 i = 1) 个值最大元素被安置在第 $n$ 个位置上。

-  继续进行第 2 趟，第 3 趟 ...，直到某一趟排序过程中不出现元素交换位置的动作，则排序结束。


## 1.3 代码实现

```python
class Solution: 
	# type hint
	def bubble_sort(self, nums: [int]) -> [int]: 
		# 第 i 趟「冒泡」 
		for i in range(len(nums) - 1): 
			flag = False # 是否发生交换的标志位 
			# 区分未排序和已排序，分成两组
			# 对数组未排序区间 [0, n - i - 1] 的元素执行「冒泡」 
			for j in range(len(nums) - i - 1): 
				# 相邻两个元素进行比较，如果前者大于后者，则交换位置 
				if nums[j] > nums[j + 1]: 
					nums[j], nums[j + 1] = nums[j + 1], nums[j] 
					flag = True 
			if not flag: # 此趟遍历未交换任何元素，直接跳出 
				break 
				
		return nums 
	
	def sort_array(self, nums: [int]) -> [int]: 
		return self.bubble_sort(nums) 
		
print(Solution().sort_array([5, 2, 3, 6, 1, 4]))
```


## 1.4 冒泡排序算法分析

###  **最佳时间复杂度**

-  $O(n)$。 最好的情况下（初始时序列已经是升序排列），只需经过 1 趟排序，总共经过 $n$ 次元素之间的比较，并且不移动元素，算法就可以结束排序。因此，冒泡排序算法的最佳时间复杂度为 $O(n)$。

### **最坏时间复杂度**

-  $O(n_2)$。最差的情况下（初始时序列已经是降序排列，或者最小值元素处在序列的最后），则需要进行 $n$ 趟排序，总共进行 $∑^n_{i=2} (i - 1) = \frac{n(n-1)}{2}$ 次元素之间的比较，因此，冒泡排序算法的最坏时间复杂度为 $O(n^2)$。

### **空间复杂度**

- $O(1)$。冒泡排序为 _原地排序算法_，只用到指针变量 $i$、$j$ 以及标志位 flag 等常数项的变量。

### **冒泡排序适用情况**

-  __冒泡排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低__。因此，_冒泡排序方法比较适合于参加排序序列的数据量较小的情况，尤其是当序列的初始状态为基本有序的情况_。

### **排序稳定性**

-  由于元素交换是在相邻元素之间进行的，不会改变相等元
- 素的相对顺序，因此，冒泡排序法是一种 **稳定排序算法**。

---

# 2 选择排序

## 2.1 算法思想

>  Selection Sort： 将数组分为两个区间: _左侧为已排序区间，右侧为未排序区间_。每趟从 _未排序区间_ 选择一个值最小的元素，放到 _已排序区间_ 的末尾，从而将该元素划分到已排序区间。

## 2.2 算法步骤：

-  假设数组的元素个数为 $n$ 个，则选择排序的算法步骤如下：

1.  初始状态，已排序区间：无，未排序区间为 $[0,n − 1]$。
2.  第 1 趟选择：
    a.  遍历未排序区间 $[0,n − 1]$，使用变量 $min\_i$ 记录区间中 _值最小的元素位置_。
    b.  将 $min\_i$ 与下标为 $0$ 处的元素交换位置。如果下标为 0 处元素就是值最小的元素位置，则不用交换。
    c.  此时，已排序空间: $[0,0]$ (共 1 个)，未排序空间： $[1,n−1]$（总共 $n−1$ 个元素）。
3.  第 2 趟选择：
    a.  遍历未排序区间 $[1,n−1]$，使用变量 $min\_i$ 记录区间中 _值最小的元素位置_。
    b.  将 $min\_i$ 与下标为 $1$ 处的元素交换位置。如果下标为 $1$ 处元素就是值最小的元素位置，则不用交换。
    c.  此时，已排序空间：$[0,1]$ ，未排序空间：$[2, n-1]$（总共 $n−2$ 个元素）。
4.  依次类推，对剩余未排序区间重复上述选择过程，直到所有元素都划分到已排序区间，排序结束。

## 2.3 代码实现

```python
class Solution:
    def selection_sort(self, nums: [int]) -> [int]:
        for i in range(len(nums) - 1):
            # 记录未排序区间中最小值的位置
            min_i = i
            for j in range(i + 1, len(nums)):
                if nums[j] < nums[min_i]:
                    min_i = j
            # 如果找到最小值的位置，将 i 位置上元素与最小值位置上的元素进行交换
            if i != min_i:
                nums[i], nums[min_i] = nums[min_i], nums[i]
        return nums

    def sort_array(self, nums: [int]) -> [int]:
        return self.selection_sort(nums)
    
print(Solution().sort_array([5, 2, 3, 6, 1, 4]))
```

## 2.4 选择排序算法分析

### **时间复杂度**

- $O(n^2)$。排序法所进行的元素之间的比较次数与序列的原始状态无关。

-  因为无论序列中元素的初始排列状态如何，第 $i$ 趟排序要找出值最小元素都需要进行 $n − i$ 次元素之间的比较。
-  因此，整个排序过程需要进行的元素之间的比较次数都相同，为 $∑^n_{i=2}(i - 1) = \frac{n(n−1)}{2}$ 次。

  ### **空间复杂度**
  
  -  $O(1)$。选择排序算法为 _原地排序算法_，只用到指针变量 $i$、$j$ 以及最小值位置 $min\underline{}i$ 等常数项的变量。

 ### **选择排序适用情况**
 
 -  __选择排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低__。因此，选择排序方法比较 _适合于参加排序序列的数据量较小的情况_。选择排序的主要优点是仅需要原地操作无需占用其他空间就可以完成排序，因此在空间复杂度要求较高时，可以考虑选择排序。

   ### **排序稳定性**
   
   -  由于值最小元素与未排序区间第 1 个元素的交换动作是在不相邻的元素之间进行的，因此很有可能会改变相等元素的相对顺序，因此，选择排序法是一种 **不稳定排序算法**。

---

# 3 插入排序

## 3.1 算法思想

>  Insertion Sort：将数组分为两个区间：_左侧为有序区间，右侧为无序区间_。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。
>

-  插入排序在每次插入一个元素时，该元素会在有序区间找到合适的位置，_因此每次插入后，有序区间都会保持有序_。

## 3.2 算法步骤

-  假设数组的元素个数为 $n$ 个，则插入排序的算法步骤如下：

1. 初始状态下，有序区间为 $[0, 0]$，无序区间为 $[1, n - 1]$。
2. 第 $1$ 趟插入：
   a. 取出无序区间 $[1, n - 1]$ 中的第 $1$ 个元素，即 $nums[1]$。
   b. 从右到左遍历有序区间中的元素，将比 $nums[1]$ 小的元素向后移动 $1$ 位。
   c. 如果遇到大于或等于 $nums[1]$ 的元素时，说明找到了插入位置，将 $nums[1]$ 插入到该位置。
   d. 插入元素后有序区间变为 $[0, 1]$，无序区间变为 $[2, n - 1]$。
3. 第 $2$ 趟插入：
   a. 取出无序区间 $[2, n - 1]$ 中的第 $1$ 个元素，即 $nums[2]$。
   b. 从右到左遍历有序区间中的元素，将比 $nums[2]$ 小的元素向后移动 $1$ 位。
   c. 如果遇到大于或等于 $nums[2]$ 的元素时，说明找到了插入位置，将 $nums[2]$ 插入到该位置。
   d. 插入元素后有序区间变为 $[0, 2]$，无序区间变为 $[3, n - 1]$。
4. 依次类推，对剩余无序区间中的元素重复上述插入过程，直到所有元素都插入到有序区间中，排序结束。


## 3.3 代码实现

```python
class Solution:
    def insertion_sort(self, nums: [int]) -> [int]:
	    # 分成两个空间，有序和无序。有序初始为下标 0
        # 遍历无序区间
        for i in range(1, len(nums)):
            temp = nums[i]
            j = i
            # 从右至左遍历有序区间
            while j > 0 and nums[j - 1] > temp:
                # 将有序区间中插入位置右侧的所有元素依次右移一位
                nums[j] = nums[j - 1]
                j -= 1
            # 将该元素插入到适当位置
            nums[j] = temp

        return nums

    def sort_array(self, nums: [int]) -> [int]:
        return self.insertion_sort(nums)
    
print(Solution().sort_array([5, 2, 3, 6, 1, 4]))
```

## 4. 插入排序算法分析

### **最佳时间复杂度**

-  $O(n)$。_最好的情况下（初始时区间已经是升序排列）_，每个元素只进行一次元素之间的比较，因而总的比较次数最少，为 $∑^n_{i = 2}1 = n − 1$，并不需要移动元素（记录），这是最好的情况。

 ### **最差时间复杂度**
 
 -  $O(n^2)$。_最差的情况下（初始时区间已经是降序排列）_，每个元素 $nums[i]$ 都要进行 $i - 1$ 次元素之间的比较，元素之间总的比较次数达到最大值，为 $∑^n_{i=2}(i − 1) = \frac{n(n−1)}{2}$。

 ### **平均时间复杂度**
 
 -  $O(n^2)$。如果区间的初始情况是随机的，即参加排序的区间中元素可能出现的各种排列的概率相同，则可取上述最小值和最大值的平均值作为插入排序时所进行的元素之间的比较次数，约为 $\frac{n^2}{4}$。
 -  由此得知，插入排序算法的平均时间复杂度为 $O(n^2)$。

 ### **空间复杂度**
 
 -  $O(1)$。插入排序算法为 _原地排序算法_，只用到指针变量 $i$、$j$ 以及表示无序区间中第 $1$ 个元素的变量等常数项的变量。
 
###  **排序稳定性**

-  在插入操作过程中，每次都讲元素插入到相等元素的右侧，并不会改变相等元素的相对顺序。因此，插入排序方法是一种 **稳定排序算法**。